.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Centrality::Pagerank 3"
.TH Graph::Centrality::Pagerank 3 "2010-08-20" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Graph::Centrality::Pagerank" \- Computes pagerank of all nodes in a graph.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2],[3,4]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges);
\&  # dumps:
\&  # {
\&  #   1 => "0.175438596989046",
\&  #   2 => "0.324561403010954",
\&  #   3 => "0.175438596989046",
\&  #   4 => "0.324561403010954",
\&  # }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Graph::Centrality::Pagerank\*(C'\fR computes the pagerank of the all nodes in a graph.
The input can be a list of edges or a Graph. \f(CW\*(C`Graph::Centrality::Pagerank\*(C'\fR is
written entirely in Perl and is not recommended for use in high performance applications.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
The method \f(CW\*(C`new\*(C'\fR creates an instance of the \f(CW\*(C`Graph::Centrality::Pagerank\*(C'\fR
class with the following parameters:
.ie n .IP """dampeningFactor""" 4
.el .IP "\f(CWdampeningFactor\fR" 4
.IX Item "dampeningFactor"
.Vb 1
\& dampeningFactor => 0.85
.Ve
.Sp
\&\f(CW\*(C`dampeningFactor\*(C'\fR is the dampening factor used when computing pagerank. It
must be a value ranging from zero to one; the default is 0.85. Note the
incidence matrix
generated from the graph is multiplied (scaled) by \f(CW\*(C`dampeningFactor\*(C'\fR, \fInot\fR
by \f(CW\*(C`1 \- dampeningFactor\*(C'\fR.
.ie n .IP """maxRelError""" 4
.el .IP "\f(CWmaxRelError\fR" 4
.IX Item "maxRelError"
.Vb 1
\& maxRelError => sqrt (machine\-epsilon)
.Ve
.Sp
\&\f(CW\*(C`maxRelError\*(C'\fR is the maximum \fIaverage\fR relative error that is permitted between
successive pagerank vectors before the iterative process to approximate the pagerank vector
should be stopped. The default is the square root of the systems machine epsilon.
Usually, most pagerank values computed will have \f(CW\*(C`\-log10(maxRelError)\*(C'\fR digits of accuracy.
\&\f(CW\*(C`maxRelError\*(C'\fR must be positive and less than or equal to 0.01.
.ie n .IP """minIterations""" 4
.el .IP "\f(CWminIterations\fR" 4
.IX Item "minIterations"
.Vb 1
\& minIterations => 0
.Ve
.Sp
\&\f(CW\*(C`minIterations\*(C'\fR is the minimum number of iterations that will be computed
before the pagerank iterations are stopped, even if \f(CW\*(C`maxRelError\*(C'\fR is achieved.
The default is zero.
.ie n .IP """maxIterations""" 4
.el .IP "\f(CWmaxIterations\fR" 4
.IX Item "maxIterations"
.Vb 1
\& maxIterations => int (2 * ((maxRelError / ln (dampeningFactor) + 1))
.Ve
.Sp
\&\f(CW\*(C`maxIterations\*(C'\fR is the maximum number of iterations that can be performed
to approximate the pagerank vector even if \f(CW\*(C`maxRelError\*(C'\fR is not achieved.
The default is \f(CW\*(C`2 * ((maxRelError / ln (dampeningFactor) + 1)\*(C'\fR. If
\&\f(CW\*(C`dampeningFactor\*(C'\fR is zero, then \f(CW\*(C`maxIterations\*(C'\fR is one. If \f(CW\*(C`dampeningFactor\*(C'\fR
is one, then \f(CW\*(C`maxIterations\*(C'\fR is equal to the total nodes in the graph.
.ie n .IP """linkSinkNodes""" 4
.el .IP "\f(CWlinkSinkNodes\fR" 4
.IX Item "linkSinkNodes"
.Vb 1
\& linkSinkNodes => 1
.Ve
.Sp
In a directed graph sink nodes are the nodes with no edges emanating out
from them. In the pagerank algorithm these nodes are automatically linked
to all other nodes in the graph. To prevent this set \f(CW\*(C`linkSinkNodes\*(C'\fR to zero;
the default is one.
.ie n .IP """directed""" 4
.el .IP "\f(CWdirected\fR" 4
.IX Item "directed"
.Vb 1
\& directed => 1
.Ve
.Sp
If \f(CW\*(C`directed\*(C'\fR is true, the pagerank computations are done with the graph
edges being directed. If \f(CW\*(C`directed\*(C'\fR is false, the pageranks are computed
treating the graph as undirected; the default value of \f(CW\*(C`directed\*(C'\fR is one.
.ie n .IP """useEdgeWeights""" 4
.el .IP "\f(CWuseEdgeWeights\fR" 4
.IX Item "useEdgeWeights"
.Vb 1
\& useEdgeWeights => 0
.Ve
.Sp
If \f(CW\*(C`useEdgeWeights\*(C'\fR is true, then any weight associated with an edge is
used in the computation of pagerank. The default weight for any edge without an
assigned weight is one. The default value of \f(CW\*(C`useEdgeWeights\*(C'\fR is zero,
which forces all edge weights to be one.
.SH "METHOD"
.IX Header "METHOD"
.ie n .SS """getPagerankOfNodes"""
.el .SS "\f(CWgetPagerankOfNodes\fP"
.IX Subsection "getPagerankOfNodes"
The method \f(CW\*(C`getPagerankOfNodes\*(C'\fR computes the pagerank of each node in the graph.
The graph can be defined using the \f(CW\*(C`graph\*(C'\fR parameter or by supplying a list of edges.
All the parameters used by the constructor \f(CW\*(C`new\*(C'\fR can also be set here and they will override
the values used with \f(CW\*(C`new\*(C'\fR. \f(CW\*(C`getPagerankOfNodes\*(C'\fR returns a reference to a hash where the
keys are the graph nodes and the values are the pageranks of the node.
.ie n .IP """graph""" 4
.el .IP "\f(CWgraph\fR" 4
.IX Item "graph"
.Vb 1
\& graph => Graph
.Ve
.Sp
\&\f(CW\*(C`graph\*(C'\fR must be a Graph object. If the \f(CW\*(C`directed\*(C'\fR parameter was not set
with the constructor \f(CW\*(C`new\*(C'\fR or with this method, then \f(CW\*(C`directed\*(C'\fR
is set to the value of Graph\->is_directed().
.ie n .IP """listOfEdges""" 4
.el .IP "\f(CWlistOfEdges\fR" 4
.IX Item "listOfEdges"
.Vb 1
\& listOfEdges => [[\*(Aqa\*(Aq,10],[10,11]]
.Ve
.Sp
\&\f(CW\*(C`listOfEdges\*(C'\fR must be a list of edges, where an edge is
a pair of strings of the form \f(CW\*(C`[from\-node, to\-node]\*(C'\fR or a triple of the
form \f(CW\*(C`[from\-node, to\-node, numeric\-edge\-weight]\*(C'\fR. Note that \f(CW\*(C`graph\*(C'\fR and \f(CW\*(C`listOfEdges\*(C'\fR can
both be defined, in which case the union of their list of edges is used to compute the
pageranks of the nodes.
.ie n .IP """listOfNodes""" 4
.el .IP "\f(CWlistOfNodes\fR" 4
.IX Item "listOfNodes"
.Vb 1
\& listOfNodes => [\*(Aqa\*(Aq,10, \*(Aqb\*(Aq]
.Ve
.Sp
\&\f(CW\*(C`listOfNodes\*(C'\fR is optional but, must be the list of nodes in the graph when provided;
it defaults to all the nodes comprising the edges in \f(CW\*(C`listOfEdges\*(C'\fR or \f(CW\*(C`graph\*(C'\fR.
.ie n .IP """nodeWeights""" 4
.el .IP "\f(CWnodeWeights\fR" 4
.IX Item "nodeWeights"
.Vb 1
\&  nodeWeights => {}
.Ve
.Sp
\&\f(CW\*(C`nodeWeights\*(C'\fR is an optional hash reference that can provide a weight for the
nodes. If \f(CW\*(C`nodeWeights\*(C'\fR is not defined for any node in the graph, then each
node has a weight of \f(CW\*(C`1/scale(@listOfNodes)\*(C'\fR. If \f(CW\*(C`nodeWeights\*(C'\fR is defined for
at least one node in the graph, then the default weight of any undefined
node is zero.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
A rather dull example with one node and no edges:
.PP
.Vb 10
\&  use Graph;
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfNodes = [1];
\&  dump $ranker\->getPagerankOfNodes (listOfNodes => $listOfNodes);
\&  # dumps:
\&  # {
\&  #   1 => 1
\&  # }
.Ve
.PP
An example of a graph with two components:
.PP
.Vb 12
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2],[3,4]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges);
\&  # dumps:
\&  # {
\&  #   1 => "0.175438596989046",
\&  #   2 => "0.324561403010954",
\&  #   3 => "0.175438596989046",
\&  #   4 => "0.324561403010954",
\&  # }
.Ve
.PP
In this case the edges are placed in a Graph:
.PP
.Vb 10
\&  use Graph;
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $listOfEdges = [[1,2],[3,4]];
\&  my $graph = Graph\->new (edges => $listOfEdges);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  dump $ranker\->getPagerankOfNodes (graph => $graph);
\&  # dumps:
\&  # {
\&  #   1 => "0.175438596989046",
\&  #   2 => "0.324561403010954",
\&  #   3 => "0.175438596989046",
\&  #   4 => "0.324561403010954",
\&  # }
.Ve
.PP
Below is the first example in the paper
\&\fIHow Google Finds Your Needle in the Web's Haystack\fR by David Austin.
.PP
.Vb 10
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2],[1,3],[2,4],[3,2],[3,5],[4,2],[4,5],[4,6],[5,6],
\&    [5,7],[5,8],[6,8],[7,5],[7,1],[7,8],[8,6],[8,7]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    dampeningFactor => 1);
\&  # dumps:
\&  # {
\&  #   1 => "0.0599999994835539",
\&  #   2 => "0.0675000002254998",
\&  #   3 => "0.0300000002967361",
\&  #   4 => "0.0674999997408677",
\&  #   5 => "0.0974999994123176",
\&  #   6 => "0.202500001447512",
\&  #   7 => "0.180000001348251",
\&  #   8 => "0.294999998045262",
\&  # }
.Ve
.PP
Below is the second example in the paper. Notice \f(CW\*(C`linkSinkNodes\*(C'\fR is
set to zero.
.PP
.Vb 8
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    dampeningFactor => 1, linkSinkNodes => 0);
\&  # dumps:
\&  # { 1 => 0, 2 => 0 }
.Ve
.PP
Below is the third example in the paper. Notice in this case
\&\f(CW\*(C`linkSinkNodes\*(C'\fR is set to one, the default value.
.PP
.Vb 8
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    dampeningFactor => 1, linkSinkNodes => 1);
\&  # dumps:
\&  # { 1 => "0.33333333209157", 2 => "0.66666666790843" }
.Ve
.PP
Below is the fourth example in the paper. The
result is different from the paper since the starting vector for
Graph::Centrality::Pagerank is
.PP
.Vb 1
\&  { 1 => "0.2", 2 => "0.2", 3 => "0.2", 4 => "0.2", 5 => "0.2" }
.Ve
.PP
while the starting vector in the paper is
.PP
.Vb 1
\&  { 1 => 1, 2 => 0, 3 => 0, 4 => 0, 5 => 0 }.
\&
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2],[2,3],[3,4],[4,5],[5,1]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    dampeningFactor => 1, linkSinkNodes => 0);
\&  # dumps:
\&  # { 1 => "0.2", 2 => "0.2", 3 => "0.2", 4 => "0.2", 5 => "0.2" }
.Ve
.PP
Below is the fifth example in the paper.
.PP
.Vb 10
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,3],[1,2],[2,4],[3,2],[3,5],[4,2],[4,5],[4,6],[5,6],
\&    [5,7],[5,8],[6,8],[7,5],[7,8],[8,6],[8,7]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    dampeningFactor => 1, linkSinkNodes => 0);
\&  # dumps:
\&  # {
\&  #   1 => 0,
\&  #   2 => "2.39601089109228e\-54",
\&  #   3 => 0,
\&  #   4 => "5.47659632249665e\-54",
\&  #   5 => "0.119999999997811",
\&  #   6 => "0.240000000003975",
\&  #   7 => "0.240000000003975",
\&  #   8 => "0.399999999994238",
\&  # }
.Ve
.PP
An example of the effect of including edge weights:
.PP
.Vb 8
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[2,1],[2,3]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges);
\&  $listOfEdges = [[2,1,2],[2,3,1]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    useEdgeWeights => 1);
\&
\&  # dumps:
\&  # all edges have weight 1.
\&  # {
\&  #   1 => "0.370129870353883",
\&  #   2 => "0.259740259292235",
\&  #   3 => "0.370129870353883",
\&  # }
\&  # edge [2, 1] has twice the weight of edge [2,3].
\&  # {
\&  #   1 => "0.406926407374432",
\&  #   2 => "0.259740259292235",
\&  #   3 => "0.333333333333333",
\&  # }
.Ve
.PP
An example of the effect of including node weights:
.PP
.Vb 8
\&  use Graph;
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my $listOfEdges = [[1,2],[2,3]];
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges);
\&  dump $ranker\->getPagerankOfNodes (listOfEdges => $listOfEdges,
\&    nodeWeights => {2 => .9, 3 => .1 });
\&
\&  # dumps:
\&  # {
\&  #   1 => "0.184416783248514",
\&  #   2 => "0.341171047056969",
\&  #   3 => "0.474412169694517",
\&  # }
\&  # {
\&  #   1 => "0.135592438389592",
\&  #   2 => "0.385846009631034",
\&  #   3 => "0.478561551979374",
\&  # }
.Ve
.PP
A example of the modules speed, or lack of.
.PP
.Vb 11
\&  use Graph::Centrality::Pagerank;
\&  use Data::Dump qw(dump);
\&  my $ranker = Graph::Centrality::Pagerank\->new();
\&  my @listOfEdges;
\&  for (my $i = 0; $i < 1000000; $i++)
\&    { push @listOfEdges, [int rand 10000, int rand 10000]; }
\&  my $startTime = time;
\&  my $pageranks = $ranker\->getPagerankOfNodes (listOfEdges => \e@listOfEdges);
\&  print time()\-$startTime . "\en";
\&  # prints:
\&  # a non\-negative integer after a long time.
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install the module run the following commands:
.PP
.Vb 4
\&  perl Makefile.PL
\&  make
\&  make test
\&  make install
.Ve
.PP
If you are on a windows box you should use 'nmake' rather than 'make'.
.SH "BUGS"
.IX Header "BUGS"
Please email bugs reports or feature requests to \f(CW\*(C`bug\-graph\-centrality\-pagerank@rt.cpan.org\*(C'\fR, or through
the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Graph\-Centrality\-Pagerank <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Graph-Centrality-Pagerank>.  The author
will be notified and you can be automatically notified of progress on the bug fix or feature request.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& Jeff Kubina<jeff.kubina@gmail.com>
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2009 Jeff Kubina. All rights reserved.
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "KEYWORDS"
.IX Header "KEYWORDS"
centrality measure, eigenvector centrality, graph, network, pagerank
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Graph
